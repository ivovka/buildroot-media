From fa3caa24cbeddbd37d265861992f4e56b2ec6816 Mon Sep 17 00:00:00 2001
From: Martin van Beurden <chadoe@xbmc.org>
Date: Sun, 8 Jul 2012 15:25:43 +0200
Subject: [PATCH 38/63] fixed: paplayer crossfade.

---
 xbmc/cores/paplayer/PAPlayer.cpp |   81 +++++++++++++++++++++++---------------
 xbmc/cores/paplayer/PAPlayer.h   |    6 ++-
 2 files changed, 54 insertions(+), 33 deletions(-)

diff --git a/xbmc/cores/paplayer/PAPlayer.cpp b/xbmc/cores/paplayer/PAPlayer.cpp
index fe805d0..81203fd 100644
--- a/xbmc/cores/paplayer/PAPlayer.cpp
+++ b/xbmc/cores/paplayer/PAPlayer.cpp
@@ -43,16 +43,18 @@
 // First one being nullsoft's nsv audio decoder format
 
 PAPlayer::PAPlayer(IPlayerCallback& callback) :
-  IPlayer            (callback),
-  CThread            ("PAPlayer"),
-  m_signalSpeedChange(false),
-  m_playbackSpeed    (1    ),
-  m_isPlaying        (false),
-  m_isPaused         (false),
-  m_isFinished       (false),
-  m_currentStream    (NULL ),
-  m_audioCallback    (NULL ),
-  m_FileItem         (new CFileItem() )
+  IPlayer              (callback),
+  CThread              ("PAPlayer"),
+  m_signalSpeedChange  (false),
+  m_playbackSpeed      (1    ),
+  m_isPlaying          (false),
+  m_isPaused           (false),
+  m_isFinished         (false),
+  m_currentStream      (NULL ),
+  m_audioCallback      (NULL ),
+  m_FileItem           (new CFileItem()),
+  m_defaultCrossfadeMS (0),
+  m_upcomingCrossfadeMS(0)
 {
 }
 
@@ -221,8 +223,12 @@ void PAPlayer::CloseAllStreams(bool fade/* = true */)
 
 bool PAPlayer::OpenFile(const CFileItem& file, const CPlayerOptions &options)
 {
-  CloseAllStreams();
-  m_crossFadeTime = g_guiSettings.GetInt("musicplayer.crossfade") * 1000;
+  m_defaultCrossfadeMS = g_guiSettings.GetInt("musicplayer.crossfade") * 1000;
+
+  if (m_streams.size() > 1 || !m_defaultCrossfadeMS)
+  {
+    CloseAllStreams();
+  }
 
   if (!QueueNextFileEx(file, false))
     return false;
@@ -236,9 +242,10 @@ bool PAPlayer::OpenFile(const CFileItem& file, const CPlayerOptions &options)
   return true;
 }
 
-void PAPlayer::UpdateCrossFadingTime(const CFileItem& file)
+void PAPlayer::UpdateCrossfadeTime(const CFileItem& file)
 {
-  if ((m_crossFadeTime = g_guiSettings.GetInt("musicplayer.crossfade") * 1000))
+  m_upcomingCrossfadeMS = m_defaultCrossfadeMS = g_guiSettings.GetInt("musicplayer.crossfade") * 1000;
+  if (m_upcomingCrossfadeMS)
   {
     if (
         file.HasMusicInfoTag() && !g_guiSettings.GetBool("musicplayer.crossfadealbumtracks") &&
@@ -250,7 +257,7 @@ void PAPlayer::UpdateCrossFadingTime(const CFileItem& file)
     )
     {
       //do not crossfade when playing consecutive albumtracks
-      m_crossFadeTime = 0;
+      m_upcomingCrossfadeMS = 0;
     }
   }
 }
@@ -262,9 +269,6 @@ bool PAPlayer::QueueNextFile(const CFileItem &file)
 
 bool PAPlayer::QueueNextFileEx(const CFileItem &file, bool fadeIn/* = true */)
 {
-  //set crossfade time for the file being queued
-  UpdateCrossFadingTime(file);
-
   StreamInfo *si = new StreamInfo();
 
   if (!si->m_decoder.Create(file, (file.m_lStartOffset * 1000) / 75))
@@ -297,6 +301,8 @@ bool PAPlayer::QueueNextFileEx(const CFileItem &file, bool fadeIn/* = true */)
     CThread::Sleep(1);
   }
 
+  UpdateCrossfadeTime(file);
+
   /* init the streaminfo struct */
   si->m_decoder.GetDataFormat(&si->m_channelInfo, &si->m_sampleRate, &si->m_encodedSampleRate, &si->m_dataFormat);
   si->m_startOffset        = file.m_lStartOffset * 1000 / 75;
@@ -309,24 +315,21 @@ bool PAPlayer::QueueNextFileEx(const CFileItem &file, bool fadeIn/* = true */)
   si->m_seekNextAtFrame    = 0;
   si->m_seekFrame          = -1;
   si->m_stream             = NULL;
-  si->m_volume             = (fadeIn && m_crossFadeTime) ? 0.0f : 1.0f;
+  si->m_volume             = (fadeIn && m_upcomingCrossfadeMS) ? 0.0f : 1.0f;
   si->m_fadeOutTriggered   = false;
   si->m_isSlaved           = false;
 
   int64_t streamTotalTime = si->m_decoder.TotalTime();
   if (si->m_endOffset)
     streamTotalTime = si->m_endOffset - si->m_startOffset;
-
-  if (streamTotalTime >= TIME_TO_CACHE_NEXT_FILE + m_crossFadeTime)
-    si->m_prepareNextAtFrame = (int)((streamTotalTime - TIME_TO_CACHE_NEXT_FILE - m_crossFadeTime) * si->m_sampleRate / 1000.0f);
+  
+  si->m_prepareNextAtFrame = 0;
+  if (streamTotalTime >= TIME_TO_CACHE_NEXT_FILE + m_defaultCrossfadeMS)
+    si->m_prepareNextAtFrame = (int)((streamTotalTime - TIME_TO_CACHE_NEXT_FILE - m_defaultCrossfadeMS) * si->m_sampleRate / 1000.0f);
 
   si->m_prepareTriggered = false;
 
-  if (streamTotalTime < m_crossFadeTime)
-    si->m_playNextAtFrame = (int)((streamTotalTime / 2) * si->m_sampleRate / 1000.0f);
-  else
-    si->m_playNextAtFrame = (int)((streamTotalTime - m_crossFadeTime) * si->m_sampleRate / 1000.0f);
-
+  si->m_playNextAtFrame = 0;
   si->m_playNextTriggered = false;
 
   PrepareStream(si);
@@ -334,12 +337,28 @@ bool PAPlayer::QueueNextFileEx(const CFileItem &file, bool fadeIn/* = true */)
   /* add the stream to the list */
   CExclusiveLock lock(m_streamsLock);
   m_streams.push_back(si);
+  //update the current stream to start playing the next track at the correct frame.
+  UpdateStreamInfoPlayNextAtFrame(m_currentStream, m_upcomingCrossfadeMS);
 
   *m_FileItem = file;
 
   return true;
 }
 
+void PAPlayer::UpdateStreamInfoPlayNextAtFrame(StreamInfo *si, unsigned int crossFadingTime)
+{
+  if (si)
+  {
+    int64_t streamTotalTime = si->m_decoder.TotalTime();
+    if (si->m_endOffset)
+      streamTotalTime = si->m_endOffset - si->m_startOffset;
+    if (streamTotalTime < crossFadingTime)
+      si->m_playNextAtFrame = (int)((streamTotalTime / 2) * si->m_sampleRate / 1000.0f);
+    else
+      si->m_playNextAtFrame = (int)((streamTotalTime - crossFadingTime) * si->m_sampleRate / 1000.0f);
+  }
+}
+
 inline bool PAPlayer::PrepareStream(StreamInfo *si)
 {
   /* if we have a stream we are already prepared */
@@ -365,7 +384,7 @@ inline bool PAPlayer::PrepareStream(StreamInfo *si)
   si->m_stream->SetReplayGain(si->m_decoder.GetReplayGain());
 
   /* if its not the first stream and crossfade is not enabled */
-  if (m_currentStream && m_currentStream != si && !m_crossFadeTime)
+  if (m_currentStream && m_currentStream != si && !m_upcomingCrossfadeMS)
   {
     /* slave the stream for gapless */
     si->m_isSlaved = true;
@@ -523,9 +542,9 @@ inline void PAPlayer::ProcessStreams(double &delay, double &buffer)
 
       if (!m_isFinished)
       {
-        if (m_crossFadeTime)
+        if (m_upcomingCrossfadeMS)
         {
-          si->m_stream->FadeVolume(1.0f, 0.0f, m_crossFadeTime);
+          si->m_stream->FadeVolume(1.0f, 0.0f, m_upcomingCrossfadeMS);
           si->m_fadeOutTriggered = true;
         }
         m_currentStream = NULL;
@@ -548,7 +567,7 @@ inline bool PAPlayer::ProcessStream(StreamInfo *si, double &delay, double &buffe
     si->m_stream->RegisterAudioCallback(m_audioCallback);
     if (!si->m_isSlaved)
       si->m_stream->Resume();
-    si->m_stream->FadeVolume(0.0f, 1.0f, m_crossFadeTime);
+    si->m_stream->FadeVolume(0.0f, 1.0f, m_upcomingCrossfadeMS);
     m_callback.OnPlayBackStarted();
   }
 
diff --git a/xbmc/cores/paplayer/PAPlayer.h b/xbmc/cores/paplayer/PAPlayer.h
index 205ea67..58a6d8e 100644
--- a/xbmc/cores/paplayer/PAPlayer.h
+++ b/xbmc/cores/paplayer/PAPlayer.h
@@ -114,7 +114,8 @@ private:
   bool                m_isPlaying;
   bool                m_isPaused;
   bool                m_isFinished;          /* if there are no more songs in the queue */
-  unsigned int        m_crossFadeTime;       /* how long the crossfade is */
+  unsigned int        m_defaultCrossfadeMS;  /* how long the default crossfade is in ms */
+  unsigned int        m_upcomingCrossfadeMS; /* how long the upcoming crossfade is in ms */
   CEvent              m_startEvent;          /* event for playback start */
   StreamInfo*         m_currentStream;       /* the current playing stream */
   IAudioCallback*     m_audioCallback;       /* the viz audio callback */
@@ -133,7 +134,8 @@ private:
   bool PrepareStream(StreamInfo *si);
   bool ProcessStream(StreamInfo *si, double &delay, double &buffer);
   bool QueueData(StreamInfo *si);
-  void UpdateCrossFadingTime(const CFileItem& file);
   int64_t GetTotalTime64();
+  void UpdateCrossfadeTime(const CFileItem& file);
+  void UpdateStreamInfoPlayNextAtFrame(StreamInfo *si, unsigned int crossFadingTime);
 };
 
-- 
1.7.9.4

